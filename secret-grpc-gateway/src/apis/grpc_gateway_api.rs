/*
 * Secret Network
 *
 * A REST interface for queries and transactions
 *
 * The version of the OpenAPI document: v1.12
 *
 * Generated by: https://openapi-generator.tech
 */
#![allow(clippy::too_many_arguments)]

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method [`account`]
#[derive(Clone, Debug, Default)]
pub struct AccountParams {
    /// address defines the address to query for.
    pub address: String,
}

/// struct for passing parameters to the method [`accounts`]
#[derive(Clone, Debug, Default)]
pub struct AccountsParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`address_by_label`]
#[derive(Clone, Debug, Default)]
pub struct AddressByLabelParams {
    pub label: String,
}

/// struct for passing parameters to the method [`all_balances`]
#[derive(Clone, Debug, Default)]
pub struct AllBalancesParams {
    /// address is the address to query balances for.
    pub address: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`all_evidence`]
#[derive(Clone, Debug, Default)]
pub struct AllEvidenceParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`allowance`]
#[derive(Clone, Debug, Default)]
pub struct AllowanceParams {
    /// granter is the address of the user granting an allowance of their funds.
    pub granter: String,
    /// grantee is the address of the user being granted an allowance of another user's funds.
    pub grantee: String,
}

/// struct for passing parameters to the method [`allowances`]
#[derive(Clone, Debug, Default)]
pub struct AllowancesParams {
    pub grantee: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`allowances_by_granter`]
#[derive(Clone, Debug, Default)]
pub struct AllowancesByGranterParams {
    pub granter: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`applied_plan`]
#[derive(Clone, Debug, Default)]
pub struct AppliedPlanParams {
    /// name is the name of the applied plan to query for.
    pub name: String,
}

/// struct for passing parameters to the method [`balance`]
#[derive(Clone, Debug, Default)]
pub struct BalanceParams {
    /// address is the address to query balances for.
    pub address: String,
    /// denom is the coin denom to query balances for.
    pub denom: Option<String>,
}

/// struct for passing parameters to the method [`broadcast_tx`]
#[derive(Clone, Debug)]
pub struct BroadcastTxParams {
    pub broadcast_tx_request: crate::models::BroadcastTxRequest,
}

/// struct for passing parameters to the method [`channel`]
#[derive(Clone, Debug, Default)]
pub struct ChannelParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
}

/// struct for passing parameters to the method [`channel_client_state`]
#[derive(Clone, Debug, Default)]
pub struct ChannelClientStateParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
}

/// struct for passing parameters to the method [`channel_consensus_state`]
#[derive(Clone, Debug, Default)]
pub struct ChannelConsensusStateParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
    /// revision number of the consensus state
    pub revision_number: String,
    /// revision height of the consensus state
    pub revision_height: String,
}

/// struct for passing parameters to the method [`channels`]
#[derive(Clone, Debug, Default)]
pub struct ChannelsParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`client_connections`]
#[derive(Clone, Debug, Default)]
pub struct ClientConnectionsParams {
    /// client identifier associated with a connection
    pub client_id: String,
}

/// struct for passing parameters to the method [`client_state`]
#[derive(Clone, Debug, Default)]
pub struct ClientStateParams {
    /// client state unique identifier
    pub client_id: String,
}

/// struct for passing parameters to the method [`client_states`]
#[derive(Clone, Debug, Default)]
pub struct ClientStatesParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`client_status`]
#[derive(Clone, Debug, Default)]
pub struct ClientStatusParams {
    /// client unique identifier
    pub client_id: String,
}

/// struct for passing parameters to the method [`code`]
#[derive(Clone, Debug, Default)]
pub struct CodeParams {
    pub code_id: String,
}

/// struct for passing parameters to the method [`code_hash_by_code_id`]
#[derive(Clone, Debug, Default)]
pub struct CodeHashByCodeIdParams {
    pub code_id: String,
}

/// struct for passing parameters to the method [`code_hash_by_contract_address`]
#[derive(Clone, Debug, Default)]
pub struct CodeHashByContractAddressParams {
    /// address is the bech32 human readable address of the contract
    pub contract_address: String,
}

/// struct for passing parameters to the method [`connection`]
#[derive(Clone, Debug, Default)]
pub struct ConnectionParams {
    /// connection unique identifier
    pub connection_id: String,
}

/// struct for passing parameters to the method [`connection_channels`]
#[derive(Clone, Debug, Default)]
pub struct ConnectionChannelsParams {
    /// connection unique identifier
    pub connection: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`connection_client_state`]
#[derive(Clone, Debug, Default)]
pub struct ConnectionClientStateParams {
    /// connection identifier
    pub connection_id: String,
}

/// struct for passing parameters to the method [`connection_consensus_state`]
#[derive(Clone, Debug, Default)]
pub struct ConnectionConsensusStateParams {
    /// connection identifier
    pub connection_id: String,
    pub revision_number: String,
    pub revision_height: String,
}

/// struct for passing parameters to the method [`connections`]
#[derive(Clone, Debug, Default)]
pub struct ConnectionsParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`consensus_state`]
#[derive(Clone, Debug, Default)]
pub struct ConsensusStateParams {
    /// client identifier
    pub client_id: String,
    /// consensus state revision number
    pub revision_number: String,
    /// consensus state revision height
    pub revision_height: String,
    /// latest_height overrrides the height field and queries the latest stored ConsensusState.
    pub latest_height: Option<bool>,
}

/// struct for passing parameters to the method [`consensus_state_heights`]
#[derive(Clone, Debug, Default)]
pub struct ConsensusStateHeightsParams {
    /// client identifier
    pub client_id: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`consensus_states`]
#[derive(Clone, Debug, Default)]
pub struct ConsensusStatesParams {
    /// client identifier
    pub client_id: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`contract_history`]
#[derive(Clone, Debug, Default)]
pub struct ContractHistoryParams {
    /// address is the address of the contract to query
    pub contract_address: String,
}

/// struct for passing parameters to the method [`contract_info`]
#[derive(Clone, Debug, Default)]
pub struct ContractInfoParams {
    /// address is the bech32 human readable address of the contract
    pub contract_address: String,
}

/// struct for passing parameters to the method [`contracts_by_code_id`]
#[derive(Clone, Debug, Default)]
pub struct ContractsByCodeIdParams {
    pub code_id: String,
}

/// struct for passing parameters to the method [`counterparty_payee`]
#[derive(Clone, Debug, Default)]
pub struct CounterpartyPayeeParams {
    /// unique channel identifier
    pub channel_id: String,
    /// the relayer address to which the counterparty is registered
    pub relayer: String,
}

/// struct for passing parameters to the method [`delegation`]
#[derive(Clone, Debug, Default)]
pub struct DelegationParams {
    /// validator_addr defines the validator address to query for.
    pub validator_addr: String,
    /// delegator_addr defines the delegator address to query for.
    pub delegator_addr: String,
}

/// struct for passing parameters to the method [`delegation_rewards`]
#[derive(Clone, Debug, Default)]
pub struct DelegationRewardsParams {
    /// delegator_address defines the delegator address to query for.
    pub delegator_address: String,
    /// validator_address defines the validator address to query for.
    pub validator_address: String,
}

/// struct for passing parameters to the method [`delegation_total_rewards`]
#[derive(Clone, Debug, Default)]
pub struct DelegationTotalRewardsParams {
    /// delegator_address defines the delegator address to query for.
    pub delegator_address: String,
}

/// struct for passing parameters to the method [`delegator_delegations`]
#[derive(Clone, Debug, Default)]
pub struct DelegatorDelegationsParams {
    /// delegator_addr defines the delegator address to query for.
    pub delegator_addr: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`delegator_unbonding_delegations`]
#[derive(Clone, Debug, Default)]
pub struct DelegatorUnbondingDelegationsParams {
    /// delegator_addr defines the delegator address to query for.
    pub delegator_addr: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`delegator_validator`]
#[derive(Clone, Debug, Default)]
pub struct DelegatorValidatorParams {
    /// delegator_addr defines the delegator address to query for.
    pub delegator_addr: String,
    /// validator_addr defines the validator address to query for.
    pub validator_addr: String,
}

/// struct for passing parameters to the method [`delegator_validators`]
#[derive(Clone, Debug, Default)]
pub struct DelegatorValidatorsParams {
    /// delegator_address defines the delegator address to query for.
    pub delegator_address: String,
}

/// struct for passing parameters to the method [`delegator_validators_info`]
#[derive(Clone, Debug, Default)]
pub struct DelegatorValidatorsInfoParams {
    /// delegator_addr defines the delegator address to query for.
    pub delegator_addr: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`delegator_withdraw_address`]
#[derive(Clone, Debug, Default)]
pub struct DelegatorWithdrawAddressParams {
    /// delegator_address defines the delegator address to query for.
    pub delegator_address: String,
}

/// struct for passing parameters to the method [`denom_hash`]
#[derive(Clone, Debug, Default)]
pub struct DenomHashParams {
    /// The denomination trace ([port_id]/[channel_id])+/[denom]
    pub trace: String,
}

/// struct for passing parameters to the method [`denom_metadata`]
#[derive(Clone, Debug, Default)]
pub struct DenomMetadataParams {
    /// denom is the coin denom to query the metadata for.
    pub denom: String,
}

/// struct for passing parameters to the method [`denom_trace`]
#[derive(Clone, Debug, Default)]
pub struct DenomTraceParams {
    /// hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information.
    pub hash: String,
}

/// struct for passing parameters to the method [`denom_traces`]
#[derive(Clone, Debug, Default)]
pub struct DenomTracesParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`denoms_metadata`]
#[derive(Clone, Debug, Default)]
pub struct DenomsMetadataParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`deposit`]
#[derive(Clone, Debug, Default)]
pub struct DepositParams {
    /// proposal_id defines the unique id of the proposal.
    pub proposal_id: String,
    /// depositor defines the deposit addresses from the proposals.
    pub depositor: String,
}

/// struct for passing parameters to the method [`deposits`]
#[derive(Clone, Debug, Default)]
pub struct DepositsParams {
    /// proposal_id defines the unique id of the proposal.
    pub proposal_id: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`encrypted_seed`]
#[derive(Clone, Debug, Default)]
pub struct EncryptedSeedParams {
    pub pub_key: String,
}

/// struct for passing parameters to the method [`escrow_address`]
#[derive(Clone, Debug, Default)]
pub struct EscrowAddressParams {
    /// unique channel identifier
    pub channel_id: String,
    /// unique port identifier
    pub port_id: String,
}

/// struct for passing parameters to the method [`evidence`]
#[derive(Clone, Debug, Default)]
pub struct EvidenceParams {
    /// evidence_hash defines the hash of the requested evidence.
    pub evidence_hash: String,
}

/// struct for passing parameters to the method [`fee_enabled_channel`]
#[derive(Clone, Debug, Default)]
pub struct FeeEnabledChannelParams {
    /// unique channel identifier
    pub channel_id: String,
    /// unique port identifier
    pub port_id: String,
}

/// struct for passing parameters to the method [`fee_enabled_channels`]
#[derive(Clone, Debug, Default)]
pub struct FeeEnabledChannelsParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
    /// block height at which to query.
    pub query_height: Option<String>,
}

/// struct for passing parameters to the method [`get_block_by_height`]
#[derive(Clone, Debug, Default)]
pub struct GetBlockByHeightParams {
    pub height: String,
}

/// struct for passing parameters to the method [`get_block_with_txs`]
#[derive(Clone, Debug, Default)]
pub struct GetBlockWithTxsParams {
    /// height is the height of the block to query.
    pub height: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`get_latest_validator_set`]
#[derive(Clone, Debug, Default)]
pub struct GetLatestValidatorSetParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`get_tx`]
#[derive(Clone, Debug, Default)]
pub struct GetTxParams {
    /// hash is the tx hash to query, encoded as a hex string.
    pub hash: String,
}

/// struct for passing parameters to the method [`get_txs_event`]
#[derive(Clone, Debug, Default)]
pub struct GetTxsEventParams {
    /// events is the list of transaction event type.
    pub events: Option<Vec<String>>,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
    ///  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
    pub order_by: Option<String>,
}

/// struct for passing parameters to the method [`get_validator_set_by_height`]
#[derive(Clone, Debug, Default)]
pub struct GetValidatorSetByHeightParams {
    pub height: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`gov_params`]
#[derive(Clone, Debug, Default)]
pub struct GovParamsParams {
    /// params_type defines which parameters to query for, can be one of \"voting\", \"tallying\" or \"deposit\".
    pub params_type: String,
}

/// struct for passing parameters to the method [`grantee_grants`]
#[derive(Clone, Debug, Default)]
pub struct GranteeGrantsParams {
    pub grantee: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`granter_grants`]
#[derive(Clone, Debug, Default)]
pub struct GranterGrantsParams {
    pub granter: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`grants`]
#[derive(Clone, Debug, Default)]
pub struct GrantsParams {
    pub granter: Option<String>,
    pub grantee: Option<String>,
    /// Optional, msg_type_url, when set, will query only grants matching given msg type.
    pub msg_type_url: Option<String>,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`historical_info`]
#[derive(Clone, Debug, Default)]
pub struct HistoricalInfoParams {
    /// height defines at which height to query the historical info.
    pub height: String,
}

/// struct for passing parameters to the method [`incentivized_packet`]
#[derive(Clone, Debug, Default)]
pub struct IncentivizedPacketParams {
    /// channel unique identifier
    pub packet_id_channel_id: String,
    /// channel port identifier
    pub packet_id_port_id: String,
    /// packet sequence
    pub packet_id_sequence: String,
    /// block height at which to query.
    pub query_height: Option<String>,
}

/// struct for passing parameters to the method [`incentivized_packets`]
#[derive(Clone, Debug, Default)]
pub struct IncentivizedPacketsParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
    /// block height at which to query.
    pub query_height: Option<String>,
}

/// struct for passing parameters to the method [`incentivized_packets_for_channel`]
#[derive(Clone, Debug, Default)]
pub struct IncentivizedPacketsForChannelParams {
    pub channel_id: String,
    pub port_id: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
    /// Height to query at.
    pub query_height: Option<String>,
}

/// struct for passing parameters to the method [`interchain_account`]
#[derive(Clone, Debug, Default)]
pub struct InterchainAccountParams {
    pub owner: String,
    pub connection_id: String,
}

/// struct for passing parameters to the method [`interchain_account_from_address`]
#[derive(Clone, Debug, Default)]
pub struct InterchainAccountFromAddressParams {
    pub owner: String,
    pub connection_id: String,
}

/// struct for passing parameters to the method [`label_by_address`]
#[derive(Clone, Debug, Default)]
pub struct LabelByAddressParams {
    /// address is the bech32 human readable address of the contract
    pub contract_address: String,
}

/// struct for passing parameters to the method [`module_account_by_name`]
#[derive(Clone, Debug, Default)]
pub struct ModuleAccountByNameParams {
    pub name: String,
}

/// struct for passing parameters to the method [`module_versions`]
#[derive(Clone, Debug, Default)]
pub struct ModuleVersionsParams {
    /// module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
    pub module_name: Option<String>,
}

/// struct for passing parameters to the method [`next_sequence_receive`]
#[derive(Clone, Debug, Default)]
pub struct NextSequenceReceiveParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
}

/// struct for passing parameters to the method [`packet_acknowledgement`]
#[derive(Clone, Debug, Default)]
pub struct PacketAcknowledgementParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
    /// packet sequence
    pub sequence: String,
}

/// struct for passing parameters to the method [`packet_acknowledgements`]
#[derive(Clone, Debug, Default)]
pub struct PacketAcknowledgementsParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
    /// list of packet sequences.
    pub packet_commitment_sequences: Option<Vec<String>>,
}

/// struct for passing parameters to the method [`packet_commitment`]
#[derive(Clone, Debug, Default)]
pub struct PacketCommitmentParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
    /// packet sequence
    pub sequence: String,
}

/// struct for passing parameters to the method [`packet_commitments`]
#[derive(Clone, Debug, Default)]
pub struct PacketCommitmentsParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`packet_receipt`]
#[derive(Clone, Debug, Default)]
pub struct PacketReceiptParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
    /// packet sequence
    pub sequence: String,
}

/// struct for passing parameters to the method [`params`]
#[derive(Clone, Debug, Default)]
pub struct ParamsParams {
    /// subspace defines the module to query the parameter for.
    pub subspace: Option<String>,
    /// key defines the key of the parameter in the subspace.
    pub key: Option<String>,
}

/// struct for passing parameters to the method [`payee`]
#[derive(Clone, Debug, Default)]
pub struct PayeeParams {
    /// unique channel identifier
    pub channel_id: String,
    /// the relayer address to which the distribution address is registered
    pub relayer: String,
}

/// struct for passing parameters to the method [`proposal`]
#[derive(Clone, Debug, Default)]
pub struct ProposalParams {
    /// proposal_id defines the unique id of the proposal.
    pub proposal_id: String,
}

/// struct for passing parameters to the method [`proposals`]
#[derive(Clone, Debug, Default)]
pub struct ProposalsParams {
    /// proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
    pub proposal_status: Option<String>,
    /// voter defines the voter address for the proposals.
    pub voter: Option<String>,
    /// depositor defines the deposit addresses from the proposals.
    pub depositor: Option<String>,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`query_secret_contract`]
#[derive(Clone, Debug, Default)]
pub struct QuerySecretContractParams {
    /// address is the bech32 human readable address of the contract
    pub contract_address: String,
    pub query: Option<String>,
}

/// struct for passing parameters to the method [`redelegations`]
#[derive(Clone, Debug, Default)]
pub struct RedelegationsParams {
    /// delegator_addr defines the delegator address to query for.
    pub delegator_addr: String,
    /// src_validator_addr defines the validator address to redelegate from.
    pub src_validator_addr: Option<String>,
    /// dst_validator_addr defines the validator address to redelegate to.
    pub dst_validator_addr: Option<String>,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`restaking_entries`]
#[derive(Clone, Debug, Default)]
pub struct RestakingEntriesParams {
    pub delegator: Option<String>,
}

/// struct for passing parameters to the method [`signing_info`]
#[derive(Clone, Debug, Default)]
pub struct SigningInfoParams {
    /// cons_address is the address to query signing info of
    pub cons_address: String,
}

/// struct for passing parameters to the method [`signing_infos`]
#[derive(Clone, Debug, Default)]
pub struct SigningInfosParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`simulate`]
#[derive(Clone, Debug)]
pub struct SimulateParams {
    pub simulate_request: crate::models::SimulateRequest,
}

/// struct for passing parameters to the method [`spendable_balances`]
#[derive(Clone, Debug, Default)]
pub struct SpendableBalancesParams {
    /// address is the address to query spendable balances for.
    pub address: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`supply_of`]
#[derive(Clone, Debug, Default)]
pub struct SupplyOfParams {
    /// denom is the coin denom to query balances for.
    pub denom: String,
}

/// struct for passing parameters to the method [`tally_result`]
#[derive(Clone, Debug, Default)]
pub struct TallyResultParams {
    /// proposal_id defines the unique id of the proposal.
    pub proposal_id: String,
}

/// struct for passing parameters to the method [`total_ack_fees`]
#[derive(Clone, Debug, Default)]
pub struct TotalAckFeesParams {
    /// channel unique identifier
    pub packet_id_channel_id: String,
    /// channel port identifier
    pub packet_id_port_id: String,
    /// packet sequence
    pub packet_id_sequence: String,
}

/// struct for passing parameters to the method [`total_recv_fees`]
#[derive(Clone, Debug, Default)]
pub struct TotalRecvFeesParams {
    /// channel unique identifier
    pub packet_id_channel_id: String,
    /// channel port identifier
    pub packet_id_port_id: String,
    /// packet sequence
    pub packet_id_sequence: String,
}

/// struct for passing parameters to the method [`total_supply`]
#[derive(Clone, Debug, Default)]
pub struct TotalSupplyParams {
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`total_timeout_fees`]
#[derive(Clone, Debug, Default)]
pub struct TotalTimeoutFeesParams {
    /// channel unique identifier
    pub packet_id_channel_id: String,
    /// channel port identifier
    pub packet_id_port_id: String,
    /// packet sequence
    pub packet_id_sequence: String,
}

/// struct for passing parameters to the method [`unbonding_delegation`]
#[derive(Clone, Debug, Default)]
pub struct UnbondingDelegationParams {
    /// validator_addr defines the validator address to query for.
    pub validator_addr: String,
    /// delegator_addr defines the delegator address to query for.
    pub delegator_addr: String,
}

/// struct for passing parameters to the method [`unreceived_acks`]
#[derive(Clone, Debug, Default)]
pub struct UnreceivedAcksParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
    /// list of acknowledgement sequences
    pub packet_ack_sequences: Vec<String>,
}

/// struct for passing parameters to the method [`unreceived_packets`]
#[derive(Clone, Debug, Default)]
pub struct UnreceivedPacketsParams {
    /// channel unique identifier
    pub channel_id: String,
    /// port unique identifier
    pub port_id: String,
    /// list of packet sequences
    pub packet_commitment_sequences: Vec<String>,
}

/// struct for passing parameters to the method [`upgraded_consensus_state_last_height`]
#[derive(Clone, Debug, Default)]
pub struct UpgradedConsensusStateLastHeightParams {
    /// last height of the current chain must be sent in request as this is the height under which next consensus state is stored
    pub last_height: String,
}

/// struct for passing parameters to the method [`validator`]
#[derive(Clone, Debug, Default)]
pub struct ValidatorParams {
    /// validator_addr defines the validator address to query for.
    pub validator_addr: String,
}

/// struct for passing parameters to the method [`validator_commission`]
#[derive(Clone, Debug, Default)]
pub struct ValidatorCommissionParams {
    /// validator_address defines the validator address to query for.
    pub validator_address: String,
}

/// struct for passing parameters to the method [`validator_delegations`]
#[derive(Clone, Debug, Default)]
pub struct ValidatorDelegationsParams {
    /// validator_addr defines the validator address to query for.
    pub validator_addr: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`validator_outstanding_rewards`]
#[derive(Clone, Debug, Default)]
pub struct ValidatorOutstandingRewardsParams {
    /// validator_address defines the validator address to query for.
    pub validator_address: String,
}

/// struct for passing parameters to the method [`validator_slashes`]
#[derive(Clone, Debug, Default)]
pub struct ValidatorSlashesParams {
    /// validator_address defines the validator address to query for.
    pub validator_address: String,
    /// starting_height defines the optional starting height to query the slashes.
    pub starting_height: Option<String>,
    /// starting_height defines the optional ending height to query the slashes.
    pub ending_height: Option<String>,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`validator_unbonding_delegations`]
#[derive(Clone, Debug, Default)]
pub struct ValidatorUnbondingDelegationsParams {
    /// validator_addr defines the validator address to query for.
    pub validator_addr: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`validators`]
#[derive(Clone, Debug, Default)]
pub struct ValidatorsParams {
    /// status enables to query for validators matching a given status.
    pub status: Option<String>,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>,
}

/// struct for passing parameters to the method [`vote`]
#[derive(Clone, Debug, Default)]
pub struct VoteParams {
    /// proposal_id defines the unique id of the proposal.
    pub proposal_id: String,
    /// voter defines the oter address for the proposals.
    pub voter: String,
}

/// struct for passing parameters to the method [`votes`]
#[derive(Clone, Debug, Default)]
pub struct VotesParams {
    /// proposal_id defines the unique id of the proposal.
    pub proposal_id: String,
    /// key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
    pub pagination_key: Option<String>,
    /// offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
    pub pagination_offset: Option<String>,
    /// limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
    pub pagination_limit: Option<String>,
    /// count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
    pub pagination_count_total: Option<bool>,
    /// reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
    pub pagination_reverse: Option<bool>
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiError {
    DefaultResponse(crate::models::DefaultResponse),
    UnknownValue(serde_json::Value),
}

pub async fn account(configuration: &configuration::Configuration, params: AccountParams) -> Result<crate::models::AccountResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/accounts/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.43
pub async fn accounts(configuration: &configuration::Configuration, params: AccountsParams) -> Result<crate::models::AccountsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/accounts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn address_by_label(configuration: &configuration::Configuration, params: AddressByLabelParams) -> Result<crate::models::AddressByLabelResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let label = params.label;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compute/v1beta1/contract_address/{label}", local_var_configuration.base_path, label=crate::apis::urlencode(label));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn all_balances(configuration: &configuration::Configuration, params: AllBalancesParams) -> Result<crate::models::AllBalancesResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/balances/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn all_evidence(configuration: &configuration::Configuration, params: AllEvidenceParams) -> Result<crate::models::AllEvidenceResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/evidence/v1beta1/evidence", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn allowance(configuration: &configuration::Configuration, params: AllowanceParams) -> Result<crate::models::AllowanceResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let granter = params.granter;
    let grantee = params.grantee;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}", local_var_configuration.base_path, granter=crate::apis::urlencode(granter), grantee=crate::apis::urlencode(grantee));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn allowances(configuration: &configuration::Configuration, params: AllowancesParams) -> Result<crate::models::AllowancesResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let grantee = params.grantee;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/feegrant/v1beta1/allowances/{grantee}", local_var_configuration.base_path, grantee=crate::apis::urlencode(grantee));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn allowances_by_granter(configuration: &configuration::Configuration, params: AllowancesByGranterParams) -> Result<crate::models::AllowancesByGranterResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let granter = params.granter;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/feegrant/v1beta1/issued/{granter}", local_var_configuration.base_path, granter=crate::apis::urlencode(granter));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn annual_provisions(configuration: &configuration::Configuration) -> Result<crate::models::AnnualProvisionsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/mint/v1beta1/annual_provisions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applied_plan(configuration: &configuration::Configuration, params: AppliedPlanParams) -> Result<crate::models::AppliedPlanResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/upgrade/v1beta1/applied_plan/{name}", local_var_configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn auth_params(configuration: &configuration::Configuration) -> Result<crate::models::AuthParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn balance(configuration: &configuration::Configuration, params: BalanceParams) -> Result<crate::models::BalanceResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let denom = params.denom;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/balances/{address}/by_denom", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = denom {
        local_var_req_builder = local_var_req_builder.query(&[("denom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn bank_params(configuration: &configuration::Configuration) -> Result<crate::models::BankParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn broadcast_tx(configuration: &configuration::Configuration, params: BroadcastTxParams) -> Result<crate::models::BroadcastTxResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let broadcast_tx_request = params.broadcast_tx_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/tx/v1beta1/txs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&broadcast_tx_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn channel(configuration: &configuration::Configuration, params: ChannelParams) -> Result<crate::models::ChannelResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn channel_client_state(configuration: &configuration::Configuration, params: ChannelClientStateParams) -> Result<crate::models::QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn channel_consensus_state(configuration: &configuration::Configuration, params: ChannelConsensusStateParams) -> Result<crate::models::QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRpcMethod1, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;
    let revision_number = params.revision_number;
    let revision_height = params.revision_height;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id), revision_number=crate::apis::urlencode(revision_number), revision_height=crate::apis::urlencode(revision_height));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn channels(configuration: &configuration::Configuration, params: ChannelsParams) -> Result<crate::models::ChannelsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn client_connections(configuration: &configuration::Configuration, params: ClientConnectionsParams) -> Result<crate::models::QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let client_id = params.client_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/connection/v1/client_connections/{client_id}", local_var_configuration.base_path, client_id=crate::apis::urlencode(client_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn client_params(configuration: &configuration::Configuration) -> Result<crate::models::ClientParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/client/v1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn client_state(configuration: &configuration::Configuration, params: ClientStateParams) -> Result<crate::models::ClientStateResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let client_id = params.client_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/client/v1/client_states/{client_id}", local_var_configuration.base_path, client_id=crate::apis::urlencode(client_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn client_states(configuration: &configuration::Configuration, params: ClientStatesParams) -> Result<crate::models::ClientStatesResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/client/v1/client_states", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn client_status(configuration: &configuration::Configuration, params: ClientStatusParams) -> Result<crate::models::ClientStatusResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let client_id = params.client_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/client/v1/client_status/{client_id}", local_var_configuration.base_path, client_id=crate::apis::urlencode(client_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn code(configuration: &configuration::Configuration, params: CodeParams) -> Result<crate::models::CodeResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let code_id = params.code_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compute/v1beta1/code/{code_id}", local_var_configuration.base_path, code_id=crate::apis::urlencode(code_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn code_hash_by_code_id(configuration: &configuration::Configuration, params: CodeHashByCodeIdParams) -> Result<crate::models::CodeHashByCodeIdResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let code_id = params.code_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compute/v1beta1/code_hash/by_code_id/{code_id}", local_var_configuration.base_path, code_id=crate::apis::urlencode(code_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn code_hash_by_contract_address(configuration: &configuration::Configuration, params: CodeHashByContractAddressParams) -> Result<crate::models::CodeHashByCodeIdResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let contract_address = params.contract_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compute/v1beta1/code_hash/by_contract_address/{contract_address}", local_var_configuration.base_path, contract_address=crate::apis::urlencode(contract_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn codes(configuration: &configuration::Configuration) -> Result<crate::models::CodesResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compute/v1beta1/codes", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn community_pool(configuration: &configuration::Configuration) -> Result<crate::models::CommunityPoolResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/community_pool", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn config(configuration: &configuration::Configuration) -> Result<crate::models::ConfigResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/base/node/v1beta1/config", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn connection(configuration: &configuration::Configuration, params: ConnectionParams) -> Result<crate::models::ConnectionResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let connection_id = params.connection_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/connection/v1/connections/{connection_id}", local_var_configuration.base_path, connection_id=crate::apis::urlencode(connection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn connection_channels(configuration: &configuration::Configuration, params: ConnectionChannelsParams) -> Result<crate::models::QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let connection = params.connection;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/connections/{connection}/channels", local_var_configuration.base_path, connection=crate::apis::urlencode(connection));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn connection_client_state(configuration: &configuration::Configuration, params: ConnectionClientStateParams) -> Result<crate::models::QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let connection_id = params.connection_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/connection/v1/connections/{connection_id}/client_state", local_var_configuration.base_path, connection_id=crate::apis::urlencode(connection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn connection_consensus_state(configuration: &configuration::Configuration, params: ConnectionConsensusStateParams) -> Result<crate::models::QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let connection_id = params.connection_id;
    let revision_number = params.revision_number;
    let revision_height = params.revision_height;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}", local_var_configuration.base_path, connection_id=crate::apis::urlencode(connection_id), revision_number=crate::apis::urlencode(revision_number), revision_height=crate::apis::urlencode(revision_height));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn connections(configuration: &configuration::Configuration, params: ConnectionsParams) -> Result<crate::models::ConnectionsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/connection/v1/connections", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn consensus_state(configuration: &configuration::Configuration, params: ConsensusStateParams) -> Result<crate::models::QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let client_id = params.client_id;
    let revision_number = params.revision_number;
    let revision_height = params.revision_height;
    let latest_height = params.latest_height;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}", local_var_configuration.base_path, client_id=crate::apis::urlencode(client_id), revision_number=crate::apis::urlencode(revision_number), revision_height=crate::apis::urlencode(revision_height));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = latest_height {
        local_var_req_builder = local_var_req_builder.query(&[("latest_height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn consensus_state_heights(configuration: &configuration::Configuration, params: ConsensusStateHeightsParams) -> Result<crate::models::QueryConsensusStateHeightsResponseIsTheResponseTypeForTheQueryConsensusStateHeightsRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let client_id = params.client_id;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/client/v1/consensus_states/{client_id}/heights", local_var_configuration.base_path, client_id=crate::apis::urlencode(client_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn consensus_states(configuration: &configuration::Configuration, params: ConsensusStatesParams) -> Result<crate::models::QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let client_id = params.client_id;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/client/v1/consensus_states/{client_id}", local_var_configuration.base_path, client_id=crate::apis::urlencode(client_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn contract_history(configuration: &configuration::Configuration, params: ContractHistoryParams) -> Result<crate::models::QueryContractHistoryResponseIsTheResponseTypeForTheQueryContractHistoryRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let contract_address = params.contract_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compute/v1beta1/contract_history/{contract_address}", local_var_configuration.base_path, contract_address=crate::apis::urlencode(contract_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn contract_info(configuration: &configuration::Configuration, params: ContractInfoParams) -> Result<crate::models::QueryContractInfoResponseIsTheResponseTypeForTheQueryContractInfoRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let contract_address = params.contract_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compute/v1beta1/info/{contract_address}", local_var_configuration.base_path, contract_address=crate::apis::urlencode(contract_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn contracts_by_code_id(configuration: &configuration::Configuration, params: ContractsByCodeIdParams) -> Result<crate::models::ContractsByCodeIdResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let code_id = params.code_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compute/v1beta1/contracts/{code_id}", local_var_configuration.base_path, code_id=crate::apis::urlencode(code_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn controller_params(configuration: &configuration::Configuration) -> Result<crate::models::ControllerParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/interchain_accounts/controller/v1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn counterparty_payee(configuration: &configuration::Configuration, params: CounterpartyPayeeParams) -> Result<crate::models::QueryCounterpartyPayeeResponseDefinesTheResponseTypeForTheCounterpartyPayeeRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let relayer = params.relayer;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/counterparty_payee", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), relayer=crate::apis::urlencode(relayer));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn current_plan(configuration: &configuration::Configuration) -> Result<crate::models::CurrentPlanResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/upgrade/v1beta1/current_plan", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegation(configuration: &configuration::Configuration, params: DelegationParams) -> Result<crate::models::DelegationResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validator_addr = params.validator_addr;
    let delegator_addr = params.delegator_addr;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}", local_var_configuration.base_path, validator_addr=crate::apis::urlencode(validator_addr), delegator_addr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegation_rewards(configuration: &configuration::Configuration, params: DelegationRewardsParams) -> Result<crate::models::DelegationRewardsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegator_address = params.delegator_address;
    let validator_address = params.validator_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}", local_var_configuration.base_path, delegator_address=crate::apis::urlencode(delegator_address), validator_address=crate::apis::urlencode(validator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegation_total_rewards(configuration: &configuration::Configuration, params: DelegationTotalRewardsParams) -> Result<crate::models::DelegationTotalRewardsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegator_address = params.delegator_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards", local_var_configuration.base_path, delegator_address=crate::apis::urlencode(delegator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_delegations(configuration: &configuration::Configuration, params: DelegatorDelegationsParams) -> Result<crate::models::DelegatorDelegationsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegator_addr = params.delegator_addr;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/delegations/{delegator_addr}", local_var_configuration.base_path, delegator_addr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_unbonding_delegations(configuration: &configuration::Configuration, params: DelegatorUnbondingDelegationsParams) -> Result<crate::models::DelegatorUnbondingDelegationsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegator_addr = params.delegator_addr;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations", local_var_configuration.base_path, delegator_addr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_validator(configuration: &configuration::Configuration, params: DelegatorValidatorParams) -> Result<crate::models::DelegatorValidatorResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegator_addr = params.delegator_addr;
    let validator_addr = params.validator_addr;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}", local_var_configuration.base_path, delegator_addr=crate::apis::urlencode(delegator_addr), validator_addr=crate::apis::urlencode(validator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_validators(configuration: &configuration::Configuration, params: DelegatorValidatorsParams) -> Result<crate::models::DelegatorValidatorsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegator_address = params.delegator_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators", local_var_configuration.base_path, delegator_address=crate::apis::urlencode(delegator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_validators_info(configuration: &configuration::Configuration, params: DelegatorValidatorsInfoParams) -> Result<crate::models::DelegatorValidatorsInfoResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegator_addr = params.delegator_addr;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators", local_var_configuration.base_path, delegator_addr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_withdraw_address(configuration: &configuration::Configuration, params: DelegatorWithdrawAddressParams) -> Result<crate::models::DelegatorWithdrawAddressResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegator_address = params.delegator_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address", local_var_configuration.base_path, delegator_address=crate::apis::urlencode(delegator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn denom_hash(configuration: &configuration::Configuration, params: DenomHashParams) -> Result<crate::models::DenomHashResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trace = params.trace;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/transfer/v1/denom_hashes/{trace}", local_var_configuration.base_path, trace=crate::apis::urlencode(trace));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn denom_metadata(configuration: &configuration::Configuration, params: DenomMetadataParams) -> Result<crate::models::DenomMetadataResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let denom = params.denom;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/denoms_metadata/{denom}", local_var_configuration.base_path, denom=crate::apis::urlencode(denom));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn denom_trace(configuration: &configuration::Configuration, params: DenomTraceParams) -> Result<crate::models::DenomTraceResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let hash = params.hash;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/transfer/v1/denom_traces/{hash}", local_var_configuration.base_path, hash=crate::apis::urlencode(hash));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn denom_traces(configuration: &configuration::Configuration, params: DenomTracesParams) -> Result<crate::models::DenomTracesResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/transfer/v1/denom_traces", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn denoms_metadata(configuration: &configuration::Configuration, params: DenomsMetadataParams) -> Result<crate::models::DenomsMetadataResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/denoms_metadata", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn deposit(configuration: &configuration::Configuration, params: DepositParams) -> Result<crate::models::DepositResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let proposal_id = params.proposal_id;
    let depositor = params.depositor;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}", local_var_configuration.base_path, proposal_id=crate::apis::urlencode(proposal_id), depositor=crate::apis::urlencode(depositor));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn deposits(configuration: &configuration::Configuration, params: DepositsParams) -> Result<crate::models::DepositsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let proposal_id = params.proposal_id;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits", local_var_configuration.base_path, proposal_id=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn distribution_params(configuration: &configuration::Configuration) -> Result<crate::models::DistributionParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn emergency_button_params(configuration: &configuration::Configuration) -> Result<crate::models::EmergencyButtonParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/emergencybutton/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn encrypted_seed(configuration: &configuration::Configuration, params: EncryptedSeedParams) -> Result<crate::models::EncryptedSeedResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pub_key = params.pub_key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/registration/v1beta1/encrypted-seed/{pub_key}", local_var_configuration.base_path, pub_key=pub_key);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn escrow_address(configuration: &configuration::Configuration, params: EscrowAddressParams) -> Result<crate::models::EscrowAddressResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn evidence(configuration: &configuration::Configuration, params: EvidenceParams) -> Result<crate::models::EvidenceResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let evidence_hash = params.evidence_hash;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/evidence/v1beta1/evidence/{evidence_hash}", local_var_configuration.base_path, evidence_hash=evidence_hash);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fee_enabled_channel(configuration: &configuration::Configuration, params: FeeEnabledChannelParams) -> Result<crate::models::QueryFeeEnabledChannelResponseDefinesTheResponseTypeForTheFeeEnabledChannelRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/fee_enabled", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fee_enabled_channels(configuration: &configuration::Configuration, params: FeeEnabledChannelsParams) -> Result<crate::models::QueryFeeEnabledChannelsResponseDefinesTheResponseTypeForTheFeeEnabledChannelsRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;
    let query_height = params.query_height;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/fee/v1/fee_enabled", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query_height {
        local_var_req_builder = local_var_req_builder.query(&[("query_height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn foundation_tax(configuration: &configuration::Configuration) -> Result<crate::models::FoundationTaxResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/foundation_tax", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_block_by_height(configuration: &configuration::Configuration, params: GetBlockByHeightParams) -> Result<crate::models::GetBlockByHeightResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let height = params.height;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/base/tendermint/v1beta1/blocks/{height}", local_var_configuration.base_path, height=crate::apis::urlencode(height));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.45.2
pub async fn get_block_with_txs(configuration: &configuration::Configuration, params: GetBlockWithTxsParams) -> Result<crate::models::GetBlockWithTxsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let height = params.height;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/tx/v1beta1/txs/block/{height}", local_var_configuration.base_path, height=crate::apis::urlencode(height));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_latest_block(configuration: &configuration::Configuration) -> Result<crate::models::GetLatestBlockResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/base/tendermint/v1beta1/blocks/latest", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_latest_validator_set(configuration: &configuration::Configuration, params: GetLatestValidatorSetParams) -> Result<crate::models::GetLatestValidatorSetResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/base/tendermint/v1beta1/validatorsets/latest", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_node_info(configuration: &configuration::Configuration) -> Result<crate::models::GetNodeInfoResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/base/tendermint/v1beta1/node_info", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_syncing(configuration: &configuration::Configuration) -> Result<crate::models::GetSyncingResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/base/tendermint/v1beta1/syncing", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_tx(configuration: &configuration::Configuration, params: GetTxParams) -> Result<crate::models::GetTxResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let hash = params.hash;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/tx/v1beta1/txs/{hash}", local_var_configuration.base_path, hash=crate::apis::urlencode(hash));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_txs_event(configuration: &configuration::Configuration, params: GetTxsEventParams) -> Result<crate::models::GetTxsEventResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let events = params.events;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;
    let order_by = params.order_by;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/tx/v1beta1/txs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = events {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("events".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("events", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order_by {
        local_var_req_builder = local_var_req_builder.query(&[("order_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_validator_set_by_height(configuration: &configuration::Configuration, params: GetValidatorSetByHeightParams) -> Result<crate::models::GetValidatorSetByHeightResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let height = params.height;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/base/tendermint/v1beta1/validatorsets/{height}", local_var_configuration.base_path, height=crate::apis::urlencode(height));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn gov_params(configuration: &configuration::Configuration, params: GovParamsParams) -> Result<crate::models::GovParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let params_type = params.params_type;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/params/{params_type}", local_var_configuration.base_path, params_type=crate::apis::urlencode(params_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.45.2
pub async fn grantee_grants(configuration: &configuration::Configuration, params: GranteeGrantsParams) -> Result<crate::models::GranteeGrantsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let grantee = params.grantee;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/authz/v1beta1/grants/grantee/{grantee}", local_var_configuration.base_path, grantee=crate::apis::urlencode(grantee));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.45.2
pub async fn granter_grants(configuration: &configuration::Configuration, params: GranterGrantsParams) -> Result<crate::models::GranterGrantsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let granter = params.granter;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/authz/v1beta1/grants/granter/{granter}", local_var_configuration.base_path, granter=crate::apis::urlencode(granter));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn grants(configuration: &configuration::Configuration, params: GrantsParams) -> Result<crate::models::GrantsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let granter = params.granter;
    let grantee = params.grantee;
    let msg_type_url = params.msg_type_url;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/authz/v1beta1/grants", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = granter {
        local_var_req_builder = local_var_req_builder.query(&[("granter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = grantee {
        local_var_req_builder = local_var_req_builder.query(&[("grantee", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = msg_type_url {
        local_var_req_builder = local_var_req_builder.query(&[("msg_type_url", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn historical_info(configuration: &configuration::Configuration, params: HistoricalInfoParams) -> Result<crate::models::HistoricalInfoResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let height = params.height;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/historical_info/{height}", local_var_configuration.base_path, height=crate::apis::urlencode(height));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn host_params(configuration: &configuration::Configuration) -> Result<crate::models::HostParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/interchain_accounts/host/v1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn incentivized_packet(configuration: &configuration::Configuration, params: IncentivizedPacketParams) -> Result<crate::models::QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let packet_id_channel_id = params.packet_id_channel_id;
    let packet_id_port_id = params.packet_id_port_id;
    let packet_id_sequence = params.packet_id_sequence;
    let query_height = params.query_height;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/fee/v1/channels/{packet_id_channel_id}/ports/{packet_id_port_id}/sequences/{packet_id_sequence}/incentivized_packet", local_var_configuration.base_path, packet_id_channel_id=crate::apis::urlencode(packet_id_channel_id), packet_id_port_id=crate::apis::urlencode(packet_id_port_id), packet_id_sequence=crate::apis::urlencode(packet_id_sequence));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query_height {
        local_var_req_builder = local_var_req_builder.query(&[("query_height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn incentivized_packets(configuration: &configuration::Configuration, params: IncentivizedPacketsParams) -> Result<crate::models::QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;
    let query_height = params.query_height;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/fee/v1/incentivized_packets", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query_height {
        local_var_req_builder = local_var_req_builder.query(&[("query_height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn incentivized_packets_for_channel(configuration: &configuration::Configuration, params: IncentivizedPacketsForChannelParams) -> Result<crate::models::QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;
    let query_height = params.query_height;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/incentivized_packets", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query_height {
        local_var_req_builder = local_var_req_builder.query(&[("query_height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn inflation(configuration: &configuration::Configuration) -> Result<crate::models::InflationResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/mint/v1beta1/inflation", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn interchain_account(configuration: &configuration::Configuration, params: InterchainAccountParams) -> Result<crate::models::InterchainAccountResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let owner = params.owner;
    let connection_id = params.connection_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/interchain_accounts/controller/v1/owners/{owner}/connections/{connection_id}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), connection_id=crate::apis::urlencode(connection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn interchain_account_from_address(configuration: &configuration::Configuration, params: InterchainAccountFromAddressParams) -> Result<crate::models::QueryInterchainAccountFromAddressResponseTheResponseTypeForTheQueryInterchainAccountAddressRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let owner = params.owner;
    let connection_id = params.connection_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/mauth/interchain_account/owner/{owner}/connection/{connection_id}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), connection_id=crate::apis::urlencode(connection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn label_by_address(configuration: &configuration::Configuration, params: LabelByAddressParams) -> Result<crate::models::LabelByAddressResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let contract_address = params.contract_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compute/v1beta1/label/{contract_address}", local_var_configuration.base_path, contract_address=crate::apis::urlencode(contract_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn mint_params(configuration: &configuration::Configuration) -> Result<crate::models::MintParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/mint/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn module_account_by_name(configuration: &configuration::Configuration, params: ModuleAccountByNameParams) -> Result<crate::models::ModuleAccountByNameResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/module_accounts/{name}", local_var_configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.43
pub async fn module_versions(configuration: &configuration::Configuration, params: ModuleVersionsParams) -> Result<crate::models::ModuleVersionsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let module_name = params.module_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/upgrade/v1beta1/module_versions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = module_name {
        local_var_req_builder = local_var_req_builder.query(&[("module_name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn next_sequence_receive(configuration: &configuration::Configuration, params: NextSequenceReceiveParams) -> Result<crate::models::QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn packet_acknowledgement(configuration: &configuration::Configuration, params: PacketAcknowledgementParams) -> Result<crate::models::QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;
    let sequence = params.sequence;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id), sequence=crate::apis::urlencode(sequence));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn packet_acknowledgements(configuration: &configuration::Configuration, params: PacketAcknowledgementsParams) -> Result<crate::models::QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;
    let packet_commitment_sequences = params.packet_commitment_sequences;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = packet_commitment_sequences {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("packet_commitment_sequences".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("packet_commitment_sequences", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn packet_commitment(configuration: &configuration::Configuration, params: PacketCommitmentParams) -> Result<crate::models::QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;
    let sequence = params.sequence;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id), sequence=crate::apis::urlencode(sequence));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn packet_commitments(configuration: &configuration::Configuration, params: PacketCommitmentsParams) -> Result<crate::models::QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn packet_receipt(configuration: &configuration::Configuration, params: PacketReceiptParams) -> Result<crate::models::QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;
    let sequence = params.sequence;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id), sequence=crate::apis::urlencode(sequence));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params(configuration: &configuration::Configuration, params: ParamsParams) -> Result<crate::models::ParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let subspace = params.subspace;
    let key = params.key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/params/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = subspace {
        local_var_req_builder = local_var_req_builder.query(&[("subspace", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn payee(configuration: &configuration::Configuration, params: PayeeParams) -> Result<crate::models::QueryPayeeResponseDefinesTheResponseTypeForThePayeeRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let relayer = params.relayer;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/payee", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), relayer=crate::apis::urlencode(relayer));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn pool(configuration: &configuration::Configuration) -> Result<crate::models::PoolResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/pool", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn proposal(configuration: &configuration::Configuration, params: ProposalParams) -> Result<crate::models::ProposalResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let proposal_id = params.proposal_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposal_id}", local_var_configuration.base_path, proposal_id=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn proposals(configuration: &configuration::Configuration, params: ProposalsParams) -> Result<crate::models::ProposalsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let proposal_status = params.proposal_status;
    let voter = params.voter;
    let depositor = params.depositor;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = proposal_status {
        local_var_req_builder = local_var_req_builder.query(&[("proposal_status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = voter {
        local_var_req_builder = local_var_req_builder.query(&[("voter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = depositor {
        local_var_req_builder = local_var_req_builder.query(&[("depositor", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn query_secret_contract(configuration: &configuration::Configuration, params: QuerySecretContractParams) -> Result<crate::models::QuerySecretContractResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let contract_address = params.contract_address;
    let query = params.query;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/compute/v1beta1/query/{contract_address}", local_var_configuration.base_path, contract_address=crate::apis::urlencode(contract_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn redelegations(configuration: &configuration::Configuration, params: RedelegationsParams) -> Result<crate::models::RedelegationsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegator_addr = params.delegator_addr;
    let src_validator_addr = params.src_validator_addr;
    let dst_validator_addr = params.dst_validator_addr;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations", local_var_configuration.base_path, delegator_addr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = src_validator_addr {
        local_var_req_builder = local_var_req_builder.query(&[("src_validator_addr", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dst_validator_addr {
        local_var_req_builder = local_var_req_builder.query(&[("dst_validator_addr", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn registration_key(configuration: &configuration::Configuration) -> Result<crate::models::RegistrationKeyResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/registration/v1beta1/registration-key", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn restake_threshold(configuration: &configuration::Configuration) -> Result<crate::models::RestakeThresholdResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/restake_threshold", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn restaking_entries(configuration: &configuration::Configuration, params: RestakingEntriesParams) -> Result<crate::models::RestakingEntriesResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegator = params.delegator;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/restake_entries", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = delegator {
        local_var_req_builder = local_var_req_builder.query(&[("delegator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn router_params(configuration: &configuration::Configuration) -> Result<crate::models::RouterParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/router/v1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn signing_info(configuration: &configuration::Configuration, params: SigningInfoParams) -> Result<crate::models::QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let cons_address = params.cons_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/slashing/v1beta1/signing_infos/{cons_address}", local_var_configuration.base_path, cons_address=crate::apis::urlencode(cons_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn signing_infos(configuration: &configuration::Configuration, params: SigningInfosParams) -> Result<crate::models::QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/slashing/v1beta1/signing_infos", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn simulate(configuration: &configuration::Configuration, params: SimulateParams) -> Result<crate::models::SimulateResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let simulate_request = params.simulate_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/tx/v1beta1/simulate", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&simulate_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn slashing_params(configuration: &configuration::Configuration) -> Result<crate::models::QueryParamsResponseIsTheResponseTypeForTheQueryParamsRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/slashing/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn spendable_balances(configuration: &configuration::Configuration, params: SpendableBalancesParams) -> Result<crate::models::SpendableBalancesResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/spendable_balances/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn staking_params(configuration: &configuration::Configuration) -> Result<crate::models::StakingParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn supply_of(configuration: &configuration::Configuration, params: SupplyOfParams) -> Result<crate::models::SupplyOfResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let denom = params.denom;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/supply/{denom}", local_var_configuration.base_path, denom=crate::apis::urlencode(denom));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn tally_result(configuration: &configuration::Configuration, params: TallyResultParams) -> Result<crate::models::TallyResultResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let proposal_id = params.proposal_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposal_id}/tally", local_var_configuration.base_path, proposal_id=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn total_ack_fees(configuration: &configuration::Configuration, params: TotalAckFeesParams) -> Result<crate::models::QueryTotalAckFeesResponseDefinesTheResponseTypeForTheTotalAckFeesRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let packet_id_channel_id = params.packet_id_channel_id;
    let packet_id_port_id = params.packet_id_port_id;
    let packet_id_sequence = params.packet_id_sequence;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/fee/v1/channels/{packet_id_channel_id}/ports/{packet_id_port_id}/sequences/{packet_id_sequence}/total_ack_fees", local_var_configuration.base_path, packet_id_channel_id=crate::apis::urlencode(packet_id_channel_id), packet_id_port_id=crate::apis::urlencode(packet_id_port_id), packet_id_sequence=crate::apis::urlencode(packet_id_sequence));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn total_recv_fees(configuration: &configuration::Configuration, params: TotalRecvFeesParams) -> Result<crate::models::QueryTotalRecvFeesResponseDefinesTheResponseTypeForTheTotalRecvFeesRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let packet_id_channel_id = params.packet_id_channel_id;
    let packet_id_port_id = params.packet_id_port_id;
    let packet_id_sequence = params.packet_id_sequence;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/fee/v1/channels/{packet_id_channel_id}/ports/{packet_id_port_id}/sequences/{packet_id_sequence}/total_recv_fees", local_var_configuration.base_path, packet_id_channel_id=crate::apis::urlencode(packet_id_channel_id), packet_id_port_id=crate::apis::urlencode(packet_id_port_id), packet_id_sequence=crate::apis::urlencode(packet_id_sequence));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn total_supply(configuration: &configuration::Configuration, params: TotalSupplyParams) -> Result<crate::models::QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/supply", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn total_timeout_fees(configuration: &configuration::Configuration, params: TotalTimeoutFeesParams) -> Result<crate::models::QueryTotalTimeoutFeesResponseDefinesTheResponseTypeForTheTotalTimeoutFeesRpc, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let packet_id_channel_id = params.packet_id_channel_id;
    let packet_id_port_id = params.packet_id_port_id;
    let packet_id_sequence = params.packet_id_sequence;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/fee/v1/channels/{packet_id_channel_id}/ports/{packet_id_port_id}/sequences/{packet_id_sequence}/total_timeout_fees", local_var_configuration.base_path, packet_id_channel_id=crate::apis::urlencode(packet_id_channel_id), packet_id_port_id=crate::apis::urlencode(packet_id_port_id), packet_id_sequence=crate::apis::urlencode(packet_id_sequence));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn transfer_params(configuration: &configuration::Configuration) -> Result<crate::models::TransferParamsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/apps/transfer/v1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn tx_key(configuration: &configuration::Configuration) -> Result<crate::models::RegistrationKeyResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/registration/v1beta1/tx-key", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn unbonding_delegation(configuration: &configuration::Configuration, params: UnbondingDelegationParams) -> Result<crate::models::UnbondingDelegationResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validator_addr = params.validator_addr;
    let delegator_addr = params.delegator_addr;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation", local_var_configuration.base_path, validator_addr=crate::apis::urlencode(validator_addr), delegator_addr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn unreceived_acks(configuration: &configuration::Configuration, params: UnreceivedAcksParams) -> Result<crate::models::QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;
    let packet_ack_sequences = params.packet_ack_sequences;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id), packet_ack_sequences=packet_ack_sequences.join(","));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn unreceived_packets(configuration: &configuration::Configuration, params: UnreceivedPacketsParams) -> Result<crate::models::QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let port_id = params.port_id;
    let packet_commitment_sequences = params.packet_commitment_sequences;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets", local_var_configuration.base_path, channel_id=crate::apis::urlencode(channel_id), port_id=crate::apis::urlencode(port_id), packet_commitment_sequences=packet_commitment_sequences.join(","));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn upgraded_client_state(configuration: &configuration::Configuration) -> Result<crate::models::UpgradedClientStateResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/client/v1/upgraded_client_states", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn upgraded_consensus_state(configuration: &configuration::Configuration) -> Result<crate::models::UpgradedConsensusStateResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ibc/core/client/v1/upgraded_consensus_states", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn upgraded_consensus_state_last_height(configuration: &configuration::Configuration, params: UpgradedConsensusStateLastHeightParams) -> Result<crate::models::UpgradedConsensusStateLastHeightResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let last_height = params.last_height;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}", local_var_configuration.base_path, last_height=crate::apis::urlencode(last_height));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator(configuration: &configuration::Configuration, params: ValidatorParams) -> Result<crate::models::QueryValidatorResponseIsResponseTypeForTheQueryValidatorRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validator_addr = params.validator_addr;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators/{validator_addr}", local_var_configuration.base_path, validator_addr=crate::apis::urlencode(validator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_commission(configuration: &configuration::Configuration, params: ValidatorCommissionParams) -> Result<crate::models::QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validator_address = params.validator_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/validators/{validator_address}/commission", local_var_configuration.base_path, validator_address=crate::apis::urlencode(validator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_delegations(configuration: &configuration::Configuration, params: ValidatorDelegationsParams) -> Result<crate::models::QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validator_addr = params.validator_addr;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators/{validator_addr}/delegations", local_var_configuration.base_path, validator_addr=crate::apis::urlencode(validator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_outstanding_rewards(configuration: &configuration::Configuration, params: ValidatorOutstandingRewardsParams) -> Result<crate::models::ValidatorOutstandingRewardsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validator_address = params.validator_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards", local_var_configuration.base_path, validator_address=crate::apis::urlencode(validator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_slashes(configuration: &configuration::Configuration, params: ValidatorSlashesParams) -> Result<crate::models::ValidatorSlashesResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validator_address = params.validator_address;
    let starting_height = params.starting_height;
    let ending_height = params.ending_height;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/validators/{validator_address}/slashes", local_var_configuration.base_path, validator_address=crate::apis::urlencode(validator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = starting_height {
        local_var_req_builder = local_var_req_builder.query(&[("starting_height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ending_height {
        local_var_req_builder = local_var_req_builder.query(&[("ending_height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_unbonding_delegations(configuration: &configuration::Configuration, params: ValidatorUnbondingDelegationsParams) -> Result<crate::models::ValidatorUnbondingDelegationsResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validator_addr = params.validator_addr;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations", local_var_configuration.base_path, validator_addr=crate::apis::urlencode(validator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validators(configuration: &configuration::Configuration, params: ValidatorsParams) -> Result<crate::models::QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRpcMethod, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let status = params.status;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn vote(configuration: &configuration::Configuration, params: VoteParams) -> Result<crate::models::VoteResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let proposal_id = params.proposal_id;
    let voter = params.voter;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}", local_var_configuration.base_path, proposal_id=crate::apis::urlencode(proposal_id), voter=crate::apis::urlencode(voter));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn votes(configuration: &configuration::Configuration, params: VotesParams) -> Result<crate::models::VotesResponse, Error> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let proposal_id = params.proposal_id;
    let pagination_key = params.pagination_key;
    let pagination_offset = params.pagination_offset;
    let pagination_limit = params.pagination_limit;
    let pagination_count_total = params.pagination_count_total;
    let pagination_reverse = params.pagination_reverse;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposal_id}/votes", local_var_configuration.base_path, proposal_id=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.count_total", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

